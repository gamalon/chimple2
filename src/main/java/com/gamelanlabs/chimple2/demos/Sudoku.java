package com.gamelanlabs.chimple2.demos;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Toolkit;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;
import java.util.Arrays;

import javax.swing.DefaultComboBoxModel;
import javax.swing.GroupLayout;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextField;

import org.apache.commons.lang3.ArrayUtils;

import com.gamelanlabs.chimple2.solvers.MetropolisHastingsSolver;
import com.gamelanlabs.chimple2.solvers.Solver;

/**
 * Extremely naive Sudoku solver.
 * 
 * @author BenL
 *
 */
public class Sudoku extends Demo {
	/**
	 * Multiplier for the cost function. Controls how much the solver is
	 * willing to "float around" looking for solutions (and not strictly
	 * descend the energy gradient).
	 */
	private static final double COSTMULTIPLIER = 2.0;
	
	/**
	 * A window where we draw the Sudoku grid to show the current progress
	 * of our stochastic search.
	 */
	protected static SudokuFrame frame = null;
	
	/**
	 * The panel where we draw the results of each program instance.
	 */
	protected SudokuPanel guigrid;
	
	/**
	 * Operation mode
	 */
	private int mode = MODE_BLOCK_PERMUTATION;
	
	/**
	 * Sudoku order
	 */
	private final int o;
	
	/**
	 * Order squared
	 */
	private final int oo;
	
	/**
	 * GUI
	 */
	private boolean gui = false;
	
	/**
	 * Create a ChimpPermutation per block.
	 */
	public static final int MODE_BLOCK_PERMUTATION = 0;
	
	/**
	 * Create a ChimpPermutation per row.
	 */
	public static final int MODE_ROW_PERMUTATION = 1;
	
	/**
	 * Create a ChimpDiscrete per cell.
	 */
	public static final int MODE_CELL_DISCRETE = 2;
	
	/**
	 * Cache the number of givens in each block/row.
	 */
	protected int[] num_givens = null;
	
	/**
	 * Cache the given digits in each block/row.
	 */
	protected int[][] digits = null;
	
	/**
	 * Constructor
	 */
	public Sudoku(int order) {
		o = order;
		oo = o*o;
	}
	
	public Sudoku() {
		this(3);
	}
	
	/**
	 * Enables the GUI.
	 */
	public void enableGUI() {
		if(o != 3) {
			JOptionPane.showMessageDialog(null, "GUI only supported for order 3 Sudoku!");
			return;
		}
		if(gui == true) return;
		gui = true;
		if(frame == null) {
			frame = new SudokuFrame();
		}
		resetGUIGrid();
	}
	
	/**
	 * Generate a random filling of the given Sudoku puzzle.
	 * 
	 * @param	args	An array where the first element is an
	 * 					int[][] representing the puzzle (with 0
	 * 					for blanks)
	 * @return	cells	The filled puzzle (but not necessarily correct).
	 */
	@Override
	public Object run(Object ... args) {
		int[][] givens = (int[][]) args[0];
		int[][] cells = new int[oo][oo];
		
		boolean populate_cache = false;
		if(digits == null) {
			num_givens = new int[oo];
			if(mode == MODE_BLOCK_PERMUTATION) {
				digits = new int[oo][oo];
			}
			populate_cache = true;
		}
		
		// Generate cells
		switch(mode) {
		case MODE_BLOCK_PERMUTATION:
			for(int i = 0; i < oo; i++) {
				int r = o*(i/o);
				int c = o*(i%o);
				
				if(populate_cache) {
					// Count the number of givens in this block
					for(int j = 0; j < o; j++) {
						for(int k = 0; k < o; k++) {
							if(givens[r + j][c + k] != 0) {
								++num_givens[i];
								digits[i][givens[r + j][c + k]-1] = givens[r + j][c + k];
							}
						}
					}
				}
				
				// Generate a permutation of the other digits for this block
				int num_blanks = oo - num_givens[i];
				int[] permutation;
				if(num_blanks > 1) {
					permutation = chimpPermutation("block"+i, oo-num_givens[i]);
				} else {
					permutation = new int[num_blanks];
					if(num_blanks == 1) permutation[0] = 1;
				}
				
				// Shift the numbers generated by the chimpPermutation to match
				// the missing digits in this block.
				for(int digit : digits[i]) {
					if(digit == 0) continue;
					for(int k = 0; k < permutation.length; k++) {
						if(permutation[k] >= digit) {
							++permutation[k];
						}
					}
				}
				
				// Fill in the block
				int index = 0;
				for(int j = 0; j < o; j++) {
					for(int k = 0; k < o; k++) {
						if(givens[r + j][c + k] != 0) {
							cells[r + j][c + k] = givens[r + j][c + k];
						} else {
							cells[r + j][c + k] = permutation[index++];
						}
					}
				}
			}
			break;
			
		case MODE_ROW_PERMUTATION:
			for(int i = 0; i < oo; i++) {
				if(populate_cache) {
					// Count the number of givens in this row
					for(int j = 0; j < oo; j++) {
						if(givens[i][j] != 0) {
							++num_givens[i];
						}
					}
				}
				
				// Generate a permutation of the other digits for this rowv
				int num_blanks = oo - num_givens[i];
				int[] permutation;
				if(num_blanks > 1) {
					permutation = chimpPermutation("row"+i, oo-num_givens[i]);
				} else {
					permutation = new int[num_blanks];
					if(num_blanks == 1) permutation[0] = 1;
				}
				
				// Shift the numbers generated by the chimpPermutation to match
				// the missing digits in this row.
				for(int j = 1; j <= oo; j++) {
					if(ArrayUtils.contains(givens[i], j)) {
						for(int k = 0; k < permutation.length; k++) {
							if(permutation[k] >= j) {
								++permutation[k];
							}
						}
					}
				}
				
				// Fill in the row
				int index = 0;
				int j = 0;
				while(index < oo) {
					if(givens[i][index] != 0) {
						cells[i][index] = givens[i][index];
						++index;
					} else {
						cells[i][index++] = permutation[j++];
					}
				}
			}
			break;
			
		case MODE_CELL_DISCRETE:
			// Generate cells
			double[] weights = new double[oo];
			Arrays.fill(weights, 1./oo);
			for(int i = 0; i < oo; i++) for(int j = 0; j < oo; j++) {
				if(givens[i][j] != 0) {
					cells[i][j] = givens[i][j];
				} else {
					cells[i][j] = chimpDiscrete("cell"+i+","+j, weights)+1;
				}
			}
			break;
			
		default:
			throw new RuntimeException("Unknown mode!");
		}
		
		// Cost function
		int cost = 0;
		for(int i = 0; i < oo; i++) {
			int[] house = new int[oo];
			
			// Row i
			if(mode != MODE_ROW_PERMUTATION) {
				cost += checkHouse(cells[i]);
			}
			
			// Column i
			for(int j = 0; j < oo; j++) {
				house[j] = cells[j][i];
			}
			cost += checkHouse(house);
			
			// Block i
			if(mode != MODE_BLOCK_PERMUTATION) {
				int blockrow = i/o;
				int blockcol = i%o;
				for(int j = 0; j < o; j++) {
					for(int k = 0; k < o; k++) {
						house[o*j+k] = cells[o*blockrow + j][o*blockcol + k];
					}
				}
				cost += checkHouse(house);
			}
		}
		
		String message;
		if(cost != 0) {
			addEnergy(cost*COSTMULTIPLIER);
			message = "Still off by "+cost+" cells.";
		} else {
			message = "Solved!";
			System.out.println("Solution:");
			for(int i = 0; i < oo; i++) {
				for(int j = 0; j < oo; j++) {
					System.out.printf("%d ", cells[i][j]);
				}
				System.out.println();
			}
			System.out.println();
			triggerEndCondition();
		}
		//System.out.println(message);
		//System.out.println(Arrays.deepToString(cells));
		if(gui) guigrid.draw(givens, cells, message);
		
		return cells;
	}
	
	/**
	 * Checks if a house (row, column, or block) is valid (contains each
	 * digit from 1 to 9). Returns the number of missing digits if the
	 * house is not valid.
	 * 
	 * @param	house	The house
	 * @return	missing	The number of missing digits (0 if house is valid)
	 */
	public int checkHouse(int[] house) {
		int missing = 0;
		for(int i = 1; i <= oo; i++) {
			if(!ArrayUtils.contains(house, i)) {
				++missing;
			}
		}
		return missing;
	}
	
	/**
	 * Harness
	 * 
	 * @param	args	Command-line arguments
	 */
	public static void main(String[] args) {
		Demo.runDemo(new Sudoku(), args);
	}

	/**
	 * Implements Demo interface.
	 * 
	 * @return	defaultarguments
	 */
	@Override
	public Object[] getDefaultArguments() {
		// 32 given (49 missing)
		/*
		return new Object[] { new int[][] {
				{4, 0, 0, 0, 0, 8, 3, 0, 5},
				{5, 6, 8, 0, 0, 0, 0, 0, 0},
				{7, 0, 0, 5, 0, 0, 9, 0, 4},
				{0, 0, 5, 0, 1, 2, 6, 0, 0},
				{8, 0, 0, 0, 5, 0, 0, 0, 3},
				{0, 0, 1, 8, 4, 0, 2, 0, 0},
				{2, 0, 4, 0, 0, 5, 0, 0, 6},
				{0, 0, 0, 0, 0, 0, 8, 4, 1},
				{1, 0, 7, 6, 0, 0, 0, 0, 9}
		} };
		*/
		
		// "Hard puzzle" from Dimple codebase
		// 22 given (61 missing)
		/*
		return new Object[] { new int[][] {
				{8, 5, 0, 0, 0, 2, 4, 0, 0},
				{7, 2, 0, 0, 0, 0, 0, 0, 9},
				{0, 0, 4, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 1, 0, 7, 0, 0, 2},
				{3, 0, 5, 0, 0, 0, 9, 0, 0},
				{0, 4, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 8, 0, 0, 7, 0},
				{0, 1, 7, 0, 0, 0, 0, 0, 0},
				{0, 0, 0, 0, 3, 6, 0, 4, 0}
		} };
		*/
		
		// "Hardest ever Sudoku puzzle" according to the internet
		// 21 given (60 missing)
		///*
		return new Object[] { new int[][] {
				{8, 0, 0, 0, 0, 0, 0, 0, 0},
				{0, 0, 3, 6, 0, 0, 0, 0, 0},
				{0, 7, 0, 0, 9, 0, 2, 0, 0},
				{0, 5, 0, 0, 0, 7, 0, 0, 0},
				{0, 0, 0, 0, 4, 5, 7, 0, 0},
				{0, 0, 0, 1, 0, 0, 0, 3, 0},
				{0, 0, 1, 0, 0, 0, 0, 6, 8},
				{0, 0, 8, 5, 0, 0, 0, 1, 0},
				{0, 9, 0, 0, 0, 0, 4, 0, 0}
		} };
		//*/
	}
	
	/**
	 * Implements Demo interface.
	 * 
	 * @param	s
	 * @return	defaultsolvearguments
	 */
	@Override
	public Object[] getDefaultsFor(Solver s) {
		// Sampler parameters
		int burnin = 50000;
		int samples = 1;
		int spacing = 0;
		
		if(s.getClass().equals(MetropolisHastingsSolver.class)) {
			return new Object[] {burnin, samples, spacing};
		}
		return new Object [] {};
	}

	/**
	 * Implements Demo interface.
	 */
	@Override
	public void display(ArrayList<Object> results) {
		System.out.println(Arrays.deepToString((int[][]) results.get(results.size()-1)));
	}
	
	/**
	 * Override superclass clone() method.
	 * 
	 * @return	clone
	 */
	@Override
	public Sudoku clone() {
		Sudoku p = (Sudoku) super.clone();
		if(gui) p.resetGUIGrid();
		return p;
	}
	
	/**
	 * Resets the internal SudokuPanel.
	 */
	private void resetGUIGrid() {
		guigrid = new SudokuPanel();
		frame.addSudokuPanel(guigrid);
	}

	/**
	 * Display class for Sudoku grid.
	 * 
	 * @author BenL
	 *
	 */
	protected class SudokuFrame extends JFrame {
		private static final long serialVersionUID = 2378461215988923242L;
		protected final JPanel top = new SudokuTopPanel();
		protected final JScrollPane scroll = new JScrollPane(top,
				JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,
				JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		
		public SudokuFrame() {
			super("Sudoku Demo");
			top.setLayout(new FlowLayout(FlowLayout.CENTER, 0, 0));
			getContentPane().add(scroll);
			setDefaultCloseOperation(EXIT_ON_CLOSE);
			setVisible(true);
		}
		
		public void addSudokuPanel(SudokuPanel panel) {
			top.add(panel);
			repack();
		}
		
		public void repack() {
			// pack() is buggy; if I use pack() here
			// the scrollbar doesn't appear. In fact, I can't even
			// just use setSize -- the problem was that I can't
			// call setSize with the same size twice in a row.
			Dimension size = getPreferredSize();
			Dimension tmpSize = new Dimension((int) size.getWidth()-1, (int) size.getHeight());
			setSize(tmpSize);
			setSize(size);
		}
	}
	
	protected class SudokuTopPanel extends JPanel {
		private static final long serialVersionUID = -2379005002858382471L;
		protected Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
		
		@Override
		public Dimension getPreferredSize() {
			int numPanels = getComponentCount();
			int panelWidth = 550;
			int panelHeight = 550;
			double screenWidth = screen.getWidth() - 20; // Need room for the scrollbar/etc
			if(panelWidth*numPanels < screenWidth) {
				// Everything can fit on one line
				return new Dimension(panelWidth*numPanels, panelHeight);
			}
			int panelsPerScreenWidth = (int) Math.floor(screenWidth/panelWidth);
			return new Dimension(panelWidth*panelsPerScreenWidth,
					panelHeight*((int) Math.ceil(((double) numPanels)/panelsPerScreenWidth)));
		}
	}
	
	/**
	 * Display class for Sudoku grid.
	 * 
	 * @author BenL
	 *
	 */
	protected class SudokuPanel extends JPanel {
		private static final long serialVersionUID = -5559867373179268629L;
		public int[][] givens = null;
		public int[][] cells = null;
		public String message = null;
		
		public SudokuPanel() {
			setBackground(Color.WHITE);
		}

	    @Override
		public Dimension getPreferredSize() {
	        return new Dimension(550, 550);
	    }
		
		@Override
		public void paintComponent(Graphics g) {
			super.paintComponent(g);
			
			// Draw grid
			for(int i = 2; i <= 9; i++) {
				if((i-1)%3 == 0) {
					int weight = 1;
					// Draw row line i, bolded
					g.fillRect(50-weight, 50*i, 450, 2*weight);
					// Draw col line i, bolded
					g.fillRect(50*i, 50-weight, 2*weight, 450);
				} else {
					// Draw row line i
					g.drawLine(50, 50*i, 500, 50*i);
					// Draw col line i
					g.drawLine(50*i, 50, 50*i, 500);
				}
			}
			
			// If SudokuFrame.draw hasn't been called yet, return.
			if(givens == null) return;
			
			// Draw cells
			for(int i = 0; i < 9; i++) {
				for(int j = 0; j < 9; j++) {
					if(givens[i][j] == 0) {
						g.setFont(new Font("Arial", Font.PLAIN, 24));
						g.setColor(Color.GRAY);
					} else {
						g.setFont(new Font("Arial", Font.BOLD, 24));
						g.setColor(Color.BLACK);
					}
					g.drawString(Integer.toString(cells[i][j]), 69+50*j, 83+50*i);
				}
			}
			
			// Draw tag
			if(tag != null) {
				g.setFont(new Font("Consolas", Font.PLAIN, 48));
				g.setColor(Color.RED);
				g.drawString(tag, 25, 75);
			}
			
			// Draw cost
			g.setFont(new Font("Arial", Font.PLAIN, 18));
			g.setColor(Color.BLUE);
			g.drawString(message, 100, 525);
		}
		public void draw(int[][] g, int[][] c, String m) {
			givens = g;
			cells = c;
			message = m;
			repaint();
		}
	}
	
	/**
	 * Returns a settings panel.
	 * 
	 * @return	panel
	 */
	@Override
	public JPanel getSettingsPanel() {
		final JPanel p = new JPanel();
		
		JLabel lblGUI = new JLabel("GUI");
		final JCheckBox cbGUI = new JCheckBox("Enable");
		cbGUI.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				if(cbGUI.isSelected()) {
					enableGUI();
					cbGUI.setEnabled(false);
				}
			}
		});
		p.add(lblGUI, cbGUI);
		
		JLabel lblMode = new JLabel("Mode");
		final JComboBox<String> cbMode = new JComboBox<String>();
		cbMode.setModel(new DefaultComboBoxModel<String>(new String[] {
				"Block permutation",
				"Row permutation",
				"Cell discrete"
			}));
		cbMode.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				if(digits == null) {
					setMode(cbMode.getSelectedIndex());
				} else {
					JOptionPane.showMessageDialog(p, "Cannot modify mode after running!");
				}
			}
		});
		p.add(lblMode,cbMode);
		
		JLabel lblOrder = new JLabel("Order");
		JTextField txtOrder = new JTextField("3");
		txtOrder.setEnabled(false);
		p.add(lblOrder, txtOrder);
		
		// Create layout
		GroupLayout layout = new GroupLayout(p);
		p.setLayout(layout);
		
		// Auto-margin, auto-padding
		layout.setAutoCreateContainerGaps(true);
		layout.setAutoCreateGaps(true);
		
		layout.setVerticalGroup(layout.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
								.addComponent(lblGUI)
								.addComponent(cbGUI)
					)
				.addGroup(
						layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
								.addComponent(lblMode)
								.addComponent(cbMode)
					)
				.addGroup(
						layout.createParallelGroup(GroupLayout.Alignment.BASELINE)
								.addComponent(lblOrder)
								.addComponent(txtOrder)
					)
			);
		
		layout.setHorizontalGroup(layout.createSequentialGroup()
				.addGroup(
						layout.createParallelGroup(GroupLayout.Alignment.LEADING)
								.addComponent(lblGUI)
								.addComponent(lblMode)
								.addComponent(lblOrder)
					)
				.addGroup(
						layout.createParallelGroup(GroupLayout.Alignment.LEADING)
								.addComponent(cbGUI)
								.addComponent(cbMode)
								.addComponent(txtOrder)
					)
			);
		
		return p;
	}
	
	/**
	 * Sets the program mode (see documentation on the MODE constants).
	 * 
	 * @param	m
	 */
	public void setMode(int m) {
		mode = m;
	}
	
	/**
	 * Cleans up this instance of the program.
	 */
	@Override
	public void cleanup() {
		super.cleanup();
		if(gui) {
			frame.top.remove(guigrid);
			if(frame.top.getComponentCount() == 0) {
				frame.setVisible(false);
				frame.dispose();
				frame = null;
			} else {
				frame.top.revalidate();
				frame.repack();
			}
		}
	}
}
